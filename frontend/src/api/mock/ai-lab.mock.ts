import type {
  AIModel,
  TestRequest,
  TestResult,
  ComparisonTestResult,
  TestHistoryResponse,
  TestStatistics,
} from '@/types/ai-lab.types.ts';

// Mock delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// Mock AI models
const mockModels: AIModel[] = [
  {
    id: 'gpt-4',
    name: 'GPT-4',
    provider: 'OpenAI',
    description: 'Most capable model, best for complex tasks',
    maxTokens: 8192,
    costPer1kTokens: 0.03,
    isAvailable: true,
  },
  {
    id: 'gpt-3.5-turbo',
    name: 'GPT-3.5 Turbo',
    provider: 'OpenAI',
    description: 'Fast and cost-effective for most tasks',
    maxTokens: 4096,
    costPer1kTokens: 0.002,
    isAvailable: true,
  },
  {
    id: 'claude-3-opus',
    name: 'Claude 3 Opus',
    provider: 'Anthropic',
    description: 'Powerful model with strong reasoning',
    maxTokens: 4096,
    costPer1kTokens: 0.015,
    isAvailable: true,
  },
  {
    id: 'claude-3-sonnet',
    name: 'Claude 3 Sonnet',
    provider: 'Anthropic',
    description: 'Balanced performance and speed',
    maxTokens: 4096,
    costPer1kTokens: 0.003,
    isAvailable: true,
  },
  {
    id: 'gemini-pro',
    name: 'Gemini Pro',
    provider: 'Google',
    description: 'Google\'s advanced AI model',
    maxTokens: 8192,
    costPer1kTokens: 0.0005,
    isAvailable: true,
  },
];

// Mock test history storage
let mockTestHistory: TestResult[] = [];

// Generate mock response
const generateMockResponse = (promptText: string, modelName: string): string => {
  const responses = [
    `Based on your prompt, here's a comprehensive analysis...\n\nKey points:\n1. ${promptText.slice(0, 30)}... is an interesting approach\n2. Consider the following aspects\n3. Implementation details would include...\n\nThis response was generated by ${modelName}.`,
    `Thank you for your prompt. Let me break this down:\n\n${promptText.slice(0, 50)}...\n\nRecommendations:\n- Approach A: Direct implementation\n- Approach B: Iterative solution\n- Approach C: Hybrid method\n\nGenerated by ${modelName} for optimal results.`,
    `Your prompt focuses on an important topic. Here's my analysis:\n\n"${promptText.slice(0, 40)}..."\n\nConsiderations:\n• Technical feasibility\n• Resource requirements\n• Timeline estimation\n• Expected outcomes\n\nProvided by ${modelName} AI model.`,
  ];
  return responses[Math.floor(Math.random() * responses.length)];
};

/**
 * Get AI models (mock)
 */
export const getAIModels = async (): Promise<AIModel[]> => {
  await delay(300);
  return mockModels;
};

/**
 * Test prompt (mock)
 */
export const testPrompt = async (request: TestRequest): Promise<TestResult> => {
  await delay(1500); // Simulate AI processing time

  const model = mockModels.find(m => m.id === request.modelId);
  if (!model) throw new Error('Model not found');

  const tokensUsed = Math.floor(Math.random() * 500) + 200;
  const cost = (tokensUsed / 1000) * model.costPer1kTokens;
  const responseTime = Math.floor(Math.random() * 2000) + 1000;

  const result: TestResult = {
    id: `test-${Date.now()}`,
    userId: '1',
    promptId: request.promptId,
    promptText: request.promptText,
    modelId: request.modelId,
    model,
    parameters: request.parameters,
    response: generateMockResponse(request.promptText, model.name),
    tokensUsed,
    cost,
    responseTime,
    createdAt: new Date().toISOString(),
    isSaved: false,
  };

  mockTestHistory.unshift(result);
  return result;
};

/**
 * Compare models (mock)
 */
export const compareModels = async (
  promptText: string,
  modelIds: string[],
  parameters: TestRequest['parameters']
): Promise<ComparisonTestResult> => {
  await delay(2000); // Longer delay for multiple models

  const results: TestResult[] = [];

  for (const modelId of modelIds) {
    const model = mockModels.find(m => m.id === modelId);
    if (!model) continue;

    const tokensUsed = Math.floor(Math.random() * 500) + 200;
    const cost = (tokensUsed / 1000) * model.costPer1kTokens;
    const responseTime = Math.floor(Math.random() * 2000) + 1000;

    const result: TestResult = {
      id: `test-${Date.now()}-${modelId}`,
      userId: '1',
      promptText,
      modelId,
      model,
      parameters,
      response: generateMockResponse(promptText, model.name),
      tokensUsed,
      cost,
      responseTime,
      createdAt: new Date().toISOString(),
      isSaved: false,
    };

    results.push(result);
    mockTestHistory.unshift(result);
  }

  return {
    id: `comparison-${Date.now()}`,
    promptText,
    results,
    createdAt: new Date().toISOString(),
  };
};

/**
 * Get test history (mock)
 */
export const getTestHistory = async (
  page: number = 1,
  pageSize: number = 20,
  modelId?: string
): Promise<TestHistoryResponse> => {
  await delay(400);

  let filtered = [...mockTestHistory];
  
  if (modelId) {
    filtered = filtered.filter(t => t.modelId === modelId);
  }

  const start = (page - 1) * pageSize;
  const end = start + pageSize;

  return {
    tests: filtered.slice(start, end).map(t => ({
      id: t.id,
      promptText: t.promptText,
      modelName: t.model.name,
      response: t.response,
      tokensUsed: t.tokensUsed,
      cost: t.cost,
      createdAt: t.createdAt,
      isSaved: t.isSaved,
    })),
    total: filtered.length,
    page,
    pageSize,
  };
};

/**
 * Save test result (mock)
 */
export const saveTestResult = async (testId: string): Promise<void> => {
  await delay(200);
  const test = mockTestHistory.find(t => t.id === testId);
  if (test) {
    test.isSaved = true;
  }
};

/**
 * Delete test result (mock)
 */
export const deleteTestResult = async (testId: string): Promise<void> => {
  await delay(300);
  mockTestHistory = mockTestHistory.filter(t => t.id !== testId);
};

/**
 * Get test statistics (mock)
 */
export const getTestStatistics = async (): Promise<TestStatistics> => {
  await delay(400);

  const totalTests = mockTestHistory.length;
  const totalTokensUsed = mockTestHistory.reduce((sum, t) => sum + t.tokensUsed, 0);
  const totalCost = mockTestHistory.reduce((sum, t) => sum + t.cost, 0);
  const averageResponseTime = totalTests > 0
    ? mockTestHistory.reduce((sum, t) => sum + t.responseTime, 0) / totalTests
    : 0;

  // Find most used model
  const modelCounts: Record<string, number> = {};
  mockTestHistory.forEach(t => {
    modelCounts[t.model.name] = (modelCounts[t.model.name] || 0) + 1;
  });
  const mostUsedModel = Object.entries(modelCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'None';

  return {
    totalTests,
    totalTokensUsed,
    totalCost,
    averageResponseTime,
    mostUsedModel,
    savedTests: mockTestHistory.filter(t => t.isSaved).length,
  };
};

